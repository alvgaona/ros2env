use anyhow::Result;
use std::fs;

use crate::distro::{get_current_distro, get_ros_root, list_distributions, validate_distro};

pub fn generate_activation_script(distro: &str, _shell: &str) -> Result<String> {
    let distro_path = validate_distro(distro)?;
    let ros_root = distro_path.display().to_string();

    let mut script = String::new();

    script.push_str(
        r#"_rosenv_strip() {
  echo "$1" | tr ':' '\n' | grep -v "/opt/ros/" | tr '\n' ':' | sed 's/:$//'
}

_rosenv_append() {
  local var_name="$1" dir="$2"
  if [ -d "$dir" ]; then
    local current
    eval "current=\$$var_name"
    if [[ ":${current}:" != *":${dir}:"* ]]; then
      eval "export $var_name=\"${current:+${current}:}${dir}\""
    fi
  fi
}

"#,
    );

    script.push_str("# Strip inherited /opt/ros paths from parent shell\n");
    for var in &[
        "PATH",
        "PYTHONPATH",
        "PKG_CONFIG_PATH",
        "CMAKE_PREFIX_PATH",
        "AMENT_PREFIX_PATH",
    ] {
        script.push_str(&format!(
            "export {var}=$(_rosenv_strip \"${var}\")\n",
            var = var
        ));
    }

    script.push_str(&format!("\n# Activate ROS 2 {}\n", distro));
    script.push_str(&format!("export ROS_DISTRO=\"{}\"\n", distro));
    script.push_str("export ROS_VERSION=\"2\"\n");
    script.push_str("export ROS_PYTHON_VERSION=\"3\"\n");

    script.push_str(&format!(
        "\n_rosenv_append AMENT_PREFIX_PATH \"{ros_root}\"\n"
    ));
    script.push_str(&format!(
        "_rosenv_append CMAKE_PREFIX_PATH \"{ros_root}\"\n"
    ));
    script.push_str(&format!("_rosenv_append PATH \"{ros_root}/bin\"\n"));
    script.push_str(&format!(
        "_rosenv_append PKG_CONFIG_PATH \"{ros_root}/lib/pkgconfig\"\n"
    ));

    script.push_str(&format!(
        "for _rosenv_pypath in \"{ros_root}\"/lib/python*/site-packages; do\n"
    ));
    script.push_str("  _rosenv_append PYTHONPATH \"$_rosenv_pypath\"\n");
    script.push_str("done\n");
    script.push_str("unset _rosenv_pypath\n");

    script.push_str("\nunset -f _rosenv_strip _rosenv_append\n");

    Ok(script)
}

pub fn generate_deactivation_script() -> String {
    r#"# Deactivate ROS 2 environment
export PATH=$(echo $PATH | tr ':' '\n' | grep -v '/opt/ros/' | tr '\n' ':')
unset ROS_DISTRO
unset ROS_VERSION
unset ROS_PYTHON_VERSION
unset AMENT_PREFIX_PATH
unset CMAKE_PREFIX_PATH
unset COLCON_PREFIX_PATH
unset PYTHONPATH
unset PKG_CONFIG_PATH
"#
    .to_string()
}

pub fn generate_shell_integration(shell: &str) -> String {
    format!(
        r#"# ROS 2 Environment Manager (rosenv)
# Generated by: rosenv init {}

rosenv() {{
    case "$1" in
        activate)
            if [ -z "$2" ]; then
                echo "Error: rosenv activate requires a distribution name"
                echo "Available: $(command rosenv list --short 2>/dev/null || echo 'run rosenv setup')"
                return 1
            fi
            
            local script
            script=$(command rosenv activate "$2" 2>&1)
            if [ $? -eq 0 ]; then
                eval "$script"
                echo "✓ Switched to ROS 2 $2"
            else
                echo "$script" >&2
                return 1
            fi
            ;;
            
        deactivate)
            if [ -z "$ROS_DISTRO" ]; then
                echo "No ROS distribution active"
                return 1
            fi
            
            local distro="$ROS_DISTRO"
            eval "$(command rosenv deactivate)"
            echo "✓ Deactivated ROS 2 $distro"
            ;;
            
        status)
            if [ -n "$ROS_DISTRO" ]; then
                echo "ROS 2 $ROS_DISTRO is active"
                echo ""
                [ -n "$ROS_VERSION" ] && echo "  ROS_VERSION:       $ROS_VERSION"
                echo "  ROS_DISTRO:        $ROS_DISTRO"
                [ -n "$AMENT_PREFIX_PATH" ] && echo "  AMENT_PREFIX_PATH: ${{AMENT_PREFIX_PATH%%:*}}..."
                
                if command -v ros2 &>/dev/null; then
                    echo ""
                    echo "ROS 2 CLI:"
                    echo "  ✓ $(which ros2)"
                fi
            else
                command rosenv status
            fi
            ;;
            
        *)
            command rosenv "$@"
            ;;
    esac
}}

# Auto-activate default distribution on shell startup (optional)
# rosenv activate humble >/dev/null 2>&1
"#,
        shell
    )
}

pub fn cmd_list(names_only: bool, short: bool) -> Result<()> {
    let distros = list_distributions()?;

    if distros.is_empty() {
        if !names_only && !short {
            println!("No ROS distributions found in /opt/ros");
            println!("\nRun: rosenv setup");
        }
        return Ok(());
    }

    if short {
        println!("{}", distros.join(" "));
    } else if names_only {
        for distro in distros {
            println!("{}", distro);
        }
    } else {
        println!("Available ROS distributions:");
        let current = get_current_distro();

        for distro in distros {
            if Some(&distro) == current.as_ref() {
                println!("  * {} (active)", distro);
            } else {
                println!("    {}", distro);
            }
        }
    }

    Ok(())
}

pub fn cmd_status() -> Result<()> {
    match get_current_distro() {
        Some(distro) => {
            println!("ROS 2 {} is active\n", distro);

            println!("Environment:");
            if let Ok(ros_version) = std::env::var("ROS_VERSION") {
                println!("  ROS_VERSION:       {}", ros_version);
            }
            println!("  ROS_DISTRO:        {}", distro);

            if let Ok(ament) = std::env::var("AMENT_PREFIX_PATH") {
                println!("  AMENT_PREFIX_PATH: {}", ament);
            }

            let setup_path = get_ros_root().join(&distro).join("setup.zsh");
            if setup_path.exists() {
                println!("\nSetup file:");
                println!("  ✓ {}", setup_path.display());
            }
        }
        None => {
            println!("No ROS 2 distribution active\n");

            let distros = list_distributions()?;
            if !distros.is_empty() {
                println!("Available distributions:");
                for distro in distros {
                    println!("  - {}", distro);
                }
                println!("\nActivate: ros-distro <distro>");
            } else {
                println!("Run: rosenv setup");
            }
        }
    }

    Ok(())
}

pub fn cmd_info(distro: &str) -> Result<()> {
    let distro_path = validate_distro(distro)?;

    println!("Distribution: {}", distro);
    println!("Path:         {}", distro_path.display());

    if distro_path.is_symlink() {
        println!("Type:         Symlink");
        if let Ok(target) = fs::read_link(&distro_path) {
            println!("Target:       {}", target.display());
        }
    } else {
        println!("Type:         Directory");
    }

    println!("\nSetup files:");
    for setup in &["setup.bash", "setup.zsh", "setup.sh"] {
        let setup_path = distro_path.join(setup);
        if setup_path.exists() {
            println!("  ✓ {}", setup);
        } else {
            println!("  ✗ {}", setup);
        }
    }

    println!("\nKey directories:");
    for dir in &["bin", "lib", "share", "include"] {
        let dir_path = distro_path.join(dir);
        if dir_path.exists() {
            if let Ok(entries) = fs::read_dir(&dir_path) {
                let count = entries.count();
                println!("  ✓ {} ({} entries)", dir, count);
            } else {
                println!("  ✓ {}", dir);
            }
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_deactivation_script() {
        let script = generate_deactivation_script();

        assert!(script.contains("unset ROS_DISTRO"));
        assert!(script.contains("unset ROS_VERSION"));
        assert!(script.contains("unset AMENT_PREFIX_PATH"));
        assert!(script.contains("unset CMAKE_PREFIX_PATH"));
        assert!(script.contains("PATH="));
    }

    #[test]
    fn test_generate_shell_integration_zsh() {
        let script = generate_shell_integration("zsh");

        assert!(script.contains("rosenv()"));
        assert!(script.contains("rosenv init zsh"));
        assert!(script.contains("case \"$1\" in"));
        assert!(script.contains("activate)"));
        assert!(script.contains("deactivate)"));
        assert!(script.contains("status)"));
    }

    #[test]
    fn test_generate_shell_integration_bash() {
        let script = generate_shell_integration("bash");

        assert!(script.contains("rosenv init bash"));
        assert!(script.contains("rosenv()"));
    }

    #[test]
    fn test_shell_integration_contains_all_commands() {
        let script = generate_shell_integration("zsh");

        let required_elements = vec![
            "activate",
            "deactivate",
            "status",
            "command rosenv",
            "eval",
            "ROS_DISTRO",
        ];

        for element in required_elements {
            assert!(
                script.contains(element),
                "Shell integration missing: {}",
                element
            );
        }
    }

    #[test]
    fn test_deactivation_script_unsets_all_vars() {
        let script = generate_deactivation_script();

        let required_unsets = vec![
            "ROS_DISTRO",
            "ROS_VERSION",
            "ROS_PYTHON_VERSION",
            "AMENT_PREFIX_PATH",
            "CMAKE_PREFIX_PATH",
            "COLCON_PREFIX_PATH",
            "PYTHONPATH",
            "PKG_CONFIG_PATH",
        ];

        for var in required_unsets {
            assert!(
                script.contains(&format!("unset {}", var)),
                "Deactivation script missing unset for: {}",
                var
            );
        }
    }
}
